{
    "text": "<p>wow i have to write an article now huh</p><p>It's been a week now. Somehow, by some absolute miracle, I haven't quit this new project yet. Hooray. Now it's time to actually write about what it is.</p><h3>What it is?</h3><p>I said in the last (or first haha) post that I was gonna try to make a Castlevania-type thing. It doesn't really look like much of anything yet, so I'm not gonna bother sharing images, but it has been coming along. I've mostly been getting the basic physics down, so stuff like walking and jumping and ducking. Friction and acceleration and gravity and all that cool stuff. It's all gonna need some more tweaking, but it's enough to get me started.</p><h3>I'm gonna talk about some details now</h3><p>It's all pretty basic stuff, but I think there's some interesting decisions to be made in the design of the physics. I don't remember whether I mentioned it in the first post or not, but I'm making this game in 001 Game Creator. Anyone reading this could probably have guessed that considering the places I intend to share this blog, but y'know. Somebody could find this thing years from now and have no idea; I gotta mention these things.</p><p>Anyhow, the point of all that is that 001 has its own physics systems and I'm mostly not using them. It would probably simplify things, but I wanna have it my way.</p><h4>So how you doin' physics then?</h4><p>I'm using Change Velocity events to push my dudes around. For the player at least, I'm running a bunch of calculations in a While/Timer in the Actor. I'm actually handling most of my input in there too, which may or may not be a good thing.</p><p>Basically, the script looks like this:</p><ol><li>Retrieve current X/Z velocities for use as momentum</li><li>Calculate and apply either ground or air friction</li><li>Identify and apply left/right input</li><li>Perform some fancy jump calculations (more on that later)</li><li>Perform some ducking calculations</li><li>Clamp the values to reasonable amounts</li><li>Set the actor's velocity to the new value</li></ol><p>So, that's the gist of it. The result of my calculations right now is a kinda floaty movement, where quite a bit of momentum is carried in midair and air turning is possible but slow. It's probably gonna take some effort to get the physics feeling just right; I might want to further reduce air control and tighten up ground deceleration a bit, but that's an adventure for another time.</p><h4>More about jumping</h4><p>Jumping is kind of a complex thing. Before we can even start jumping, we need to know if we're allowed to. This mostly means determining whether we're standing on the ground or not. There's actually not a super-simple way to do this, as far as I can tell; I did it with a Line Collision branch in a custom script. I've done things like this before, but this time I knew about a couple of usevalues that make it a little nicer.</p><p>It's actually possible to get an actor's collision's position data, which makes the custom script very simple and flexible. I just have to pass through an actor and the script retrieves <code>Actor().CollisionX1</code> and <code>Actor().CollisionX2</code>, which represent the left and right edges of an actor's collsion respectively. Actually, I use <code>Actor().CollisionX2 - 1</code> for the right side because it otherwise seems to cause the line collision to hit walls when the player stands next to them.</p><p>That takes care of floor detection, but what about input? At first I just checked that the control was pressed and the actor was on the ground; if so, a jump would occur. The problem was that you would then jump repeatedly when holding the jump button. This isn't a huge deal on flat surfaces, but it becomes a problem when dealing with platforms. Specifically, when jumping to a higher platform, holding the jump button would cause you to immediately jump off of the higher platform after touching it. This felt awkward, especially given my floaty physics, so I decided to fix it.</p><p>I didn't just want to disallow holding the button to jump repeatedly though. I wanted to implement some basic input buffering. That is, after jumping, the player would be required to release the button before jumping again. But if the player released the button and then held it down again before landing, the jump should go off automatically upon hitting the ground. This makes situations where the player wants to jump repeatedly feel dramatically better, while avoiding the issues caused by allowing hold-to-jump.</p><p>I implemented input buffering on jumps by setting a variable if the jump button is released while the player is midair. I also record whether Jump was being held on the previous tick or not. Then, if Jump is being pressed now and was not on the previous tick, jumping is permitted. Alternatively, if Jump is pressed now and was on the previous tick and the jump buffer variable is set, jumping is permitted. If neither of those cases occur, jumping is not permitted.</p><p>There is a small problem with this setup, and it's that jumps will not be buffered after walking off the edge of a platform. However, it should be possible to resolve this by setting the jump buffer variable when no floor is detected this tick, floor was detected last tick, and Jump is not being pressed.</p><h4>Slopes and Collision Quirks</h4><p>001 supports slopes. This is cool, but they're kinda jank. When walking down a slope, gravity typically isn't strong enough to keep an actor attached to it. This means that you get a weird sort of bumping effect where the actor walks on air off the slope, falls down, hits the slope again, and repeats. This causes all sorts of problems.</p><p>Besides looking jank, bouncing off the edge of a slope means that you're not touching the ground for a while, and that means your jumps aren't gonna work until you land again. And since my physics work differently depending on whether the actor is on the ground or in the air, this causes control to become weird and erratic when dealing with slopes.</p><p>Now initially, I had planned to just not use slopes and everything would be fine. But then, another problem arose: <em>ground collision</em>.</p><p>For some reason (I'll describe why I suspect it happens in a moment), my actor doesn't always land properly. Sometimes, it seems to stop a few pixels above the ground and restart falling from zero velocity. This causes issues similar to the slope problem: jumping immediately after landing occasionally fails, and it looks real jank.</p><p>I think this occurs because the downwards velocity is high enough to collide with the ground on the next frame, while the actor is still a few pixels above the ground. To prevent the actor from embedding itself in the ground, the engine zeroes out its Z velocity. Of course, the actor isn't actually on the ground, so it then proceeds fall slower and lands on the ground proper. Naturally I don't know that this is really the case as I don't have access to the engine's internals, but it seems like a strong possibility.</p><p>So, how to fix it? This one took a minute to get working right, and my solution still has some issues.</p><p>I've got a second timer in my actor, running every frame. The script basically checks whether there is any ground near enough that the actor might hit it given its current velocity, and records the Z coordinate if there is. This is done via a couple of Line Sweep events. If there is ground nearby, it snaps the actor to the ground by immediately positioning it at the recorded coordinate.</p><p>My solution looks a little funny, but does solve both issues. It would be much better if the slope problem at least was fixed in the engine, so I'll send a bug report at some point. Probably around the time I share this post in the discord.</p><h3>That's all I got</h3><p>That's the end of my post for this week. Got kinda long, but that might be a good thing? I dunno. I hope at least it was all comprehensible. It's been a while since I really put serious effort into 001, and I'm feelin' good about getting back into it. In the future I should probably put a bit more effort into documenting my thoughts as I work; that might make for an easier time writing at the end of the week.</p><p>Anyway, now that my mind dump is over, what am I gonna do next week? I see two possibilities. I'm probably gonna try to find a nicer way to write these posts, because random HTML editors on the internet seem to be of subpar quality. And obviously I'm gonna keep working on the game. The next step seems to be getting some sort of weapon working, which is gonna be an adventure, and then enemies. After that, I think I can start looking at basic level design? We'll know for sure when we get there.</p>"
}
